# Внутреннее устройство docker-compose.yml

1. **version: "3.3"**  отвечает за версионирование докера
    1. **services:**     отвечает за наши сервисы, которые мы будем использовать в нашем приложении, здесь перечисляются настройки по созданию образов этих сервисов
        1. **api:** один из наших сервисов
            1. **build: ./api** отвечает за путь к папке где будет лежать Dockerfile, собирающий образ для данного сервиса
                1. **context: buildContext** - указывается контекст в котором будет искаться наш Dockerfile и выполняться команды
                1. **dockerfile: Dockerfile.dev** - явно указываем название Dockerfile
            1. **container_name: ./frontend** дает точное название будущему контейнеру
            1. **command: npm run start** Здесь указываем те команды, которые будут выполняться при старте нашего сервиса
            1. **ports:** здесь мы указываем какие порты будут доступны снаружи нашего контейнера
                1. **- "45454:3000"** здесь мы указываем порт снаружи (45454 мир) и порт контейнера (сервиса) соответственно, сопоставляем их. Лучше сопоставлять их один в один, чтобы избежать путаницы
            1. **depends_on:** 
                1. **- api_db** здесь мы указывает от каких образов зависит наш сервис, т.е. какие сервисы должны быть запущены прежде, чем запустится тот, где мы указали **depends_on**
            1. **volumes:** - хранилища, которые не чистятся при повторном rebuild'e (в них можно хранить данные, которые не должны быть утеряны)
                1. **- mongodb_api:/data/db** - слева название хранилища, справа путь, по которому будут храниться данные
                1. **- ./nginx/nginx.conf.prod:/etc/nginx/conf.d/nginx.conf** - показываем что файл настроек для прода автоматически будет помещен в настройки для дева
            1. **networks:**
                1. **- networkName** - здесь мы указываем сети, в которых будет виден наш контейнер, если ничего не написано, контейнер использует дефолтную сеть

        1. **volumes:**
            1. **mongodb_api:** - когда мы так пишем, мы указываем на то, что данные лежащие в данном хранилище мы можем использовать в любом сервисе, есди нам это нужно
        1. **networks:**
            1. **newtwork-name:**
                1. **driver: bridge** - так надо
    

**Только при подключении nginx**
         ports:  нам не нужны порты чтобы достигать этот сервис снаружи, так как все наши запросы теперь идут через nginx
            - "3000:3000"  теперь нам эти порты не нужны так как у нас nginx определяет какой порт и что вызвать

# Команды в Dockerfile

    ...-alpine - образ, из которого убрано практически все что можно, чтобы уменьшить вес образа максимально.

    Устанавливаем рабочую директорию, лучше давать осмысленные названия, хотя иногда и /app тоже подойдет

**WORKDIR /usr/src/app**


    Копируем все пакеты с названием package*.json в нашу рабочую директорию ./

COPY package*.json ./

    После того как докер скопирует эти файла выше, он запустит команду установки npm-пакетов 

**RUN npm install**

    Копируем все файлы которые лежат в папке /api внутрь нашего контейнера, так нужно, чтобы докер не копировал нашу папку с node_modules, которая лежит локально, мы добавили .dockerignore файл с указанием какие файлы и папки не надо копировать

**COPY . .**

    Указываем какой порт будет открыт из докер контейнера для внешнего мира, указываем тот порт, который прослушивает наш сервер

**EXPOSE 3000**

    Команда для того, чтобы запустить наш веб сервер

**CMD ["node", "run start"]**

*Последние две команды не советуют писать в Dockerfile, а лучше - в docker-compose.yml, чтобы наш сервер был более удобно конфигурируемым при локальной и продакшен разработке*

# Прочее

**Docker-compose up --build** - сначала сбоирает образ, если он был обновлен, а затем поднимает контейнер

**Docker-compose up -d** - позволяет запустить контейнеры, НЕ БЛОКИРУЯ консоль

**docker logs realworlddocker_udemy_api_db_1 (имя контейнера)** - выводит все логи только от этого контейнера на экран

**docker volume** - команда для отображения и управления хранилищами

**docker-compose -f docker-compose.yml -f docker-compose.development.yml up --build** - запускает наш *docker-compose.yml* c перегрузкой в виде *docker-compose.development.yml*, т.е. берет все поля из *docker-compose.yml* и перезаписывает те, что нужны, используя *docker-compose.development.yml*

**docker ps** - показывает все запущенные процессы в докере (контейнеры)

**docker exec -it <containerName> <command>** - выполняет заданную команду внутри контейнера. Лучше писать команды в shell, т.е. *docker exec -it <containerName> sh* - открывает нам shell внутри папки контейнера

**docker network** - вернет хелпы по данной команде (ls выведет все текущие сети)
    Сети позволяют объединять несколько контейнеров между собой, для того, чтобы они могли обмениваться данными

**docker system** - выводит основные команды для работы с самим докером непосредственно (больше нужно для чистки ненужных файлов на текущий момент)

**docker system prune** - чистит остановленные контейнеры, неиспользуемы сети образы, тома и кеши сборки и всякое другое (полезная вещь)

# docker-compose.development.yml
1. **version: '3.3'**

1. **services:**
    1. **api:**
        1. **command: npm run dev** - при билде и запуске *docker-compose.development.yml* будет испоользовать все поля и данные из *docker-compose.yml*, перезаписывая те данные,которые мы указали в *docker-compose.development.yml*
        1. **volumes:**
            1. **- ./api/src:/usr/src/app/scr** - это хранилище без имени (inline), так как у него нет имени его никто не может переиспользовать, и в нем мы сообщаем, что мы хотим симулинкнуть нашу папку *./api/src* внутрь по путю */usr/src/app/scr* (этот путь мы взяли из Dockerfile)
# Nodemon
Помогает пересобирать образы и выполнять другие команды, при изменении файлов проекта
Установка:
    nmp install nodemon
{
    "verbose": false, // помогает, смотреть что происходит (отладка)
    "watch": ["src"], // показываем у каких папок будем отслеживать изменения
    "exec": "node src/index.js" // указываем команду, которую будем выполнять при отлавливании изменений
}

# Дефолтный порт в интернете - 80! Всю управляющую логику запускать на 80 порту

# NGINX

server{
    listen 80; // порт для прослушивания

    server_name realworld-docker.com; // указываем домен

    location / { // все запросы которые придут на / будут прокосированы и неважно что будет дальше
        proxy_pass http://frontend:3000; // показываем куда будем редиректить
    }
}